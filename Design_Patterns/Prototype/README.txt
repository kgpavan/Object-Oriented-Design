

PROTOTYPE DESIGN PATTERN 
------------------------

You need objects to work with; objects interact with each other to get the job done. But sometimes, creating a heavy object could become costly, and if your application needs too many of that kind of objects (containing almost similar properties), it might create some performance issues.

Let us consider a scenario where an application requires some access control. The features of the applications can be used by the users according to the access rights provided to them. For example, some users have access to the reports generated by the application, while some don’t. Some of them even can modify the reports, while some can only read it. Some users also have administrative rights to add or even remove other users.

Every user object has an access control object, which is used to provide or restrict the controls of the application. This access control object is a bulky, heavy object and its creation is very costly since it requires data to be fetched from some external resources, like databases or some property files etc.

We also cannot share the same access control object with users of the same level, because the rights can be changed at runtime by the administrator and a different user with the same level could have a different access control. One user object should have one access control object.

We can use the Prototype Design Pattern to resolve this problem by creating the access control objects on all levels at once, and then provide a copy of the object to the user whenever required. In this case, data fetching from the external resources happens only once. Next time, the access control object is created by copying the existing one. The access control object is not created from scratch every time the request is sent; this approach will certainly reduce object creation time.






The Prototype design pattern is used to specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.

The concept is to copy an existing object rather than creating a new instance from scratch, something that may include costly operations. The existing object acts as a prototype and contains the state of the object. The newly copied object may change same properties only if required. This approach saves costly resources and time, especially when the object creation is a heavy process.

In Java, there are certain ways to copy an object in order to create a new one. One way to achieve this is using the Cloneable interface. Java provides the clone method, which an object inherits from the Object class. You need to implement the Cloneable interface and override this clonemethod according to your needs.


---------------------------------------------------------------------------------
Prototype
---------
Declares an interface for cloning itself.

ConcretePrototype
-----------------
Implements an operation for cloning itself.

Client
------
Creates a new object by asking a prototype to clone itself.

Prototypes let you incorporate a new concrete product class into a system simply by registering a prototypical instance with the client.
---------------------------------------------------------------------------------






---------------------------------------------------------------------------------------

------
Intent
------

Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype. Co-opt one instance of a class for use as a breeder of all future instances. The new operator considered harmful. 

-------
Problem 
-------
Application "hard wires" the class of object to create in each "new" expression.

----------
Discussion
----------

Declare an abstract base class that specifies a pure virtual "clone" method, and, maintains a dictionary of all "cloneable" concrete derived classes. Any class that 
needs a "polymorphic constructor" capability: derives itself from the abstract base class, registers its prototypical instance, and implements the clone() operation.

The client then, instead of writing code that invokes the "new" operator on a hard-wired class name, calls a "clone" operation on the abstract base class, supplying a string or enumerated data type that designates the particular concrete derived class desired.



CHECK LIST
----------

Add a clone() method to the existing "product" hierarchy.
Design a "registry" that maintains a cache of prototypical objects. The registry could be encapsulated in a new Factory class, or in the base class of the "product" hierarchy.
Design a factory method that: may (or may not) accept arguments, finds the correct prototype object, calls clone() on that object, and returns the result.
The client replaces all references to the new operator with calls to the factory method.



Rules of thumb
--------------

Sometimes creational patterns are competitors: there are cases when either Prototype or Abstract Factory could be used properly. At other times they are complementary: Abstract Factory might store a set of Prototypes from which to clone and return product objects. Abstract Factory, Builder, and Prototype can use Singleton in their implementations.
Abstract Factory classes are often implemented with Factory Methods, but they can be implemented using Prototype.

Factory Method: creation through inheritance. Prototype: creation through delegation.
Often, designs start out using Factory Method (less complicated, more customizable, subclasses proliferate) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, more complex) as the designer discovers where more flexibility is needed.
Prototype doesn't require subclassing, but it does require an "initialize" operation. Factory Method requires subclassing, but doesn't require Initialize.

Designs that make heavy use of the Composite and Decorator patterns often can benefit from Prototype as well.

Prototype co-opts one instance of a class for use as a breeder of all future instances.
Prototypes are useful when object initialization is expensive, and you anticipate few variations on the initialization parameters. In this context, Prototype can avoid expensive "creation from scratch", and support cheap cloning of a pre-initialized prototype.
Prototype is unique among the other creational patterns in that it doesn't require a class – only an object. Object-oriented languages like Self and Omega that do away with classes completely rely on prototypes for creating new objects.
---------------------------------------------------------------------------------------







Participants

    The classes and objects participating in this pattern are:

Prototype  (ColorPrototype)
declares an interface for cloning itself
ConcretePrototype  (Color)
implements an operation for cloning itself
Client  (ColorManager)
creates a new object by asking a prototype to clone itself



